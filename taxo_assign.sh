#!/bin/sh

#--------------------------------------------------------------------------#
# Taxonomic assignment using a combination of Mash and GTDB relying on WGS #
#--------------------------------------------------------------------------#

# input file is a list of paths to fasta/fastq files. one for each genome that needs to be annotated.
# output directory will contain all the annotations generated by the script.

while getopts ":i:o:" opt; do
    case "$opt" in
    i)  input=$OPTARG
        ;;
    o)  output=$OPTARG
        ;;
    esac
done

# check whether the output dir already exists or if it needs to be created

if [ ! -d "$output" ]; then
  mkdir "$output"
fi

# run MASH on all genomes (one by one for now)
while read p; do
	name=$(echo "$p" | sed -r "s/.+\/(.+)\..+/\1/")
	mash screen -w -v 0.1 -p 8 /lustre/scratch118/infgen/team162/ys4/alcohol_liver_EF_5206/mash_reads_qc/refseq.genomes.k21s1000.msh $p > ${output}/${name}_screen.tab
done < "${input}"

#extract genome ID for best hit
while read p; do
	name=$(echo "$p" | sed -r "s/.+\/(.+)\..+/\1/")
	sort -k1 -rn  ${output}/${name}_screen.tab | head -n1 | cut -f5 | sed 's/\.[1-9]_.*//g' >> ${output}/merge_results.txt
done < "${input}"

# extract Mash similarity score for the best hit
while read p; do
        name=$(echo "$p" | sed -r "s/.+\/(.+)\..+/\1/")
        sort -k1 -rn  ${output}/${name}_screen.tab | head -n1 | cut -f1 >> ${output}/merge_results.scores
done < "${input}"

# get the corresponding species taxid
while read p; do
	anno=$(echo $p | awk '{ gsub("F","A",$1); print $0 }')
	grep "$p\|$anno" /nfs/team162/kv4/github/metagm/metagm_data/bac_metadata_r86_rsonly.tsv | head -n1 | cut -f 66 >> ${output}/merge_results.taxid
done < ${output}/merge_results.txt

# get the corresponding species names
while read p; do
	anno=$(echo $p | awk '{ gsub("F","A",$1); print $0 }')
        species=$(grep "$p\|$anno" /nfs/team162/kv4/github/metagm/metagm_data/bac_metadata_r86_rsonly.tsv | head -n1 | cut -f 92 | awk '{ gsub(".*;s__", "") ; print $0 }')
	# WARNING: return only genome names when new species
	# what if there is no species name:
	if [ "${species}" = '' ]; then
		species=$(grep "$p\|$anno" /nfs/team162/kv4/github/metagm/metagm_data/bac_metadata_r86_rsonly.tsv | head -n1 | cut -f 92 | awk '{ gsub(";s__", "") ; print $0 }' | awk '{ gsub(";*__;", "") ; print $0 }' | awk '{ gsub(".*__", "") ; print $0 }')	
	fi

 	echo $species >> ${output}/merge_results.names
done < ${output}/merge_results.txt



# get the corresponding lane IDs
while read p; do
	name=$(echo "$p" | sed -r "s/.+\/(.+)\..+/\1/" | awk '{ gsub(".contigs_velvet", "") ; print $0 }')
        echo $name >> ${output}/merge_results.lane
done < "${input}"

# merge laneID and species
paste ${output}/merge_results.names ${output}/merge_results.lane | sed 's/\t/ /' > ${output}/merge_results.fullname

# get merged file
paste "${input}" ${output}/merge_results.fullname ${output}/merge_results.taxid ${output}/merge_results.scores | sed 's/\t/,/g' > ${output}/merge_final.csv

rm ${output}/merge_results.names
rm ${output}/merge_results.fullname
rm ${output}/merge_results.lane
rm ${output}/merge_results.taxid
rm ${output}/merge_results.txt
rm ${output}/merge_results.scores
